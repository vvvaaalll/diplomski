
%Prva naredba uvijek definira klasu dokumenta. Mi koristimo 'article'

\documentclass[a4paper,12pt,oneside]{article}




%***********************************************************************************
% Sada slijedi niz poziva Paketa funkcija cije ce se naredbe kasnije koristiti:
%***********************************************************************************

%Paket za upravljanje sa listama
\usepackage{enumitem}

% Paket za podesavanje brojeva stranica
\usepackage{scrlayer-scrpage}                  
	\ifoot[]{}
	\cfoot[]{}
	\ofoot[\pagemark]{\pagemark}
	\pagestyle{scrplain}
	
	
% Najcesce koristeni paketi za matematiku i formatiranje rada:
\usepackage{amsmath, amsthm}
\usepackage{mathtools}
\usepackage{latexsym,amsfonts,amssymb,amsbsy,graphics}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage[croatian]{babel} %Omogucava pisanje hrvatskih znakoba
\usepackage{gensymb}
\usepackage{pdfpages}  %Omogucava importiranje stranica pdf fila u dokument
\usepackage{pdflscape} %Omogucava okretanje pojedine stranice landscape dok su ostale portrait


% Paket za postavke naslova i podnaslova
\usepackage{titlesec}  
	\newcommand{\periodafter}[1]{#1.}
	\titleformat{\section}[hang]{\bf\large\uppercase}{\thesection.}{5pt}{}{}
	\titleformat{\subsection}[hang]{\bf\large}{\thesubsection.}{3pt}{}{}

% Dva paketa za imenovanje slika i tablica
\usepackage{subcaption}
\usepackage[labelfont=bf,textfont=it,labelsep = colon]{caption}  
	\captionsetup[figure]{name=SL.}
	\captionsetup[table]{name=Tab.}

% Paket sa bojama za formatiranje svega gdje se mjenja boja
\usepackage{xcolor}

% Paket za omogucavanje importiranja programskih kodova u tekst
\usepackage{listings} 
	\lstset{
  		numbers=left,
  		numberstyle=\tiny,
  		columns=fullflexible,
  		breaklines=true,
  		postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
  		xleftmargin=5.0ex
	}
	\renewcommand{\lstlistingname}{Primjer koda}% Listing -> Algorithm

% Paket za formatiranje Sadrzaja
\usepackage[dotinlabels]{titletoc}
	\dottedcontents{section}[5em]{\bfseries}{2em}{1pc}
	\dottedcontents{subsection}[7em]{}{2em}{1pc}
	
	
	
% Najbolji paket u svemiru za matematicko pisanje tekstova
\usepackage{physics}

% Paket za postavljanje linkova na koje se moze klikat u pdfu (prema formuli broj x- click odvede na to)
\usepackage{hyperref}                 
\hypersetup{
    colorlinks,
    linkcolor={red!50!black},
    citecolor={blue!50!black},
    urlcolor={blue!80!black}
}


% Postavke margina stranica - NE DIRAJ

\setlength{\topmargin}{-0.7in}             
\setlength{\oddsidemargin}{-2mm}
\setlength{\evensidemargin}{-2mm}
\setlength{\textwidth}{170mm}
\setlength{\textheight}{256mm}
\setlength{\parindent}{1cm}


%**************************************************************************************************************
% Prostor za tvoje pakete je ovdje:
%**************************************************************************************************************

\usepackage[backend=biber, style=numeric]{biblatex}
\addbibresource{./supp_files/bibtex_baza.bib} 


% Paket za podršku za Unicode znakove s prelomom linije
\usepackage{newunicodechar}

% Definicija Unicode znakova s prelomom linije
\newunicodechar{́}{\nobreak\hspace{-1ex}\'{}} % U+0301
\newunicodechar{̌}{\nobreak\hspace{-1ex}\v{}} % U+030C
\DeclareUnicodeCharacter{2212}{-}


\usepackage{multicol}








%**************************************************************************************************************




%Kraj preamble naredbi, krece se sa pisanjem dokumenta
%**************************************************************************************************************


\begin{document}

%**************************************************************************************************************
% Postavke za numeriranje, prorede i ostalo
%**************************************************************************************************************

\setcounter{MaxMatrixCols}{20}                          %Postavka da matrica moze imati vise od 10 stupaca
\renewcommand{\baselinestretch}{1.5}                    %postavke za prored 1.5%
\renewcommand{\thefigure}{\thesection.\arabic{figure}}  %postavke za imenovanje slika po poglavljima%
\renewcommand{\thetable}{\thesection.\arabic{table}}   %postavke za imenovanje tablica po poglavljima%
\renewcommand{\theequation}{\thesection-\arabic{equation}} %postavke za brojanje jednadzbi po poglavljima%
\renewcommand{\refname}{Literatura}						% Uppercase Literatura

%**************************************************************************************************************




%**************************************************************************************************************
% NASLOVNA STRANICA
%**************************************************************************************************************

\begin{titlepage}

\begin{center}{\sc\Large sveu\v{c}ili\v{s}te josipa jurja strossmayera u osijeku}\\{\sc\Large fakultet elektrotehnike, ra\v{c}unarstva i informacijskih tehnologija osijek}\\
\bigskip

\vspace*{2cm}
{\large Sveučilišni studij}\\

\vspace*{7cm}

{\sc\LARGE Kontinuirana integracija primjenom dockera i gitlab pipelinea}

\vspace*{1cm}
{\large Diplomski rad}\\
\vspace*{3cm}
{\Large Valentin Loboda}\\
\vspace*{6cm}
{\normalsize Osijek, 2023.}
\end{center}

\end{titlepage}



%**************************************************************************************************************
% OBRASCI I FORMULARI
%**************************************************************************************************************

% Ubaciti pdf verzije D1 obrazca i izjave o originalnosti. 


%\newpage
%\includepdf{D1_obrazac.pdf}
%\newpage
%\includepdf{Originalnost.pdf}
%\newpage




%**************************************************************************************************************
% TABLE OF CONTENTS
%**************************************************************************************************************

{
	\hypersetup{linkcolor=black}
	\tableofcontents
}
%**************************************************************************************************************



\newpage
\section{Uvod}

U današnjem okruženju brzog razvoja softvera, ključno je usvojiti prakse koje osiguravaju učinkovitost, kvalitetu i pravovremenu isporuku softverskih rješanja. Kontinuirana integracija (CI) pojavila se kao temeljni koncept u ovom kontekstu. Automatizacijom procesa integriranja promjena koda, izvođenja testova i izgradnje artefakata, CI omogućuje razvojnim timovima otkrivanje i rješavanje problema rano u razvojnom ciklusu. To zauzvrat dovodi do poboljšane suradnje, smanjenih rizika i brže isporuke softvera.
Cilj ovog rada je istražiti i opisati koncept kontinuirane integracije na primjeru gitlab cjevovoda te istražiti alternativne platforme korištene za kontinuiranu integraciju. Ispitujući temeljna načela i najbolje prakse CIa, pružiti opće razumijevanje njegovih prednosti i izazova. gitlab cjevovod, često je korišten CI/CD alat koji omogućuje automatizaciju cijelog cjevovoda isporuke softvera, od upravljanja izvornim kodom, verzioniranja, testiranja do pokretanja aplikacije u oblaku, gdje je dostupna korisnicima.
Za prikaz rada gitlab cjevovod i uvid u implementaciju kontinuirane integracije, razvijena je web aplikacija u programskom jeziku java, koristeći spring boot okvir. Odabrana tema za aplikaciju je backend aplikacija za vođenje evidencije tarantula u hobiju teraristike, aplikacija korisnicima omogućuje upravljanje svojim terarijima, praćenje životnog ciklusa tarantula te vođenje evidencije hranjenja i ponašanja. Implementacijom kontinuirane integracije i gitlab cjevovoda u proces razvoja, cilj je prikazati prednosti ovih praksi u poboljšanju učinkovitosti, kvalitete i pouzdanosti životnog ciklusa razvoja softvera.

Rad je podijeljen u sedam poglavlja. Drugo poglavlje daje pregled kontinuirane integracije, uključujući njezinu definiciju, prednosti i izazove. Opisuje temeljna načela i najbolje prakse CIa, ističući njegovu ulogu u postizanju visokokvalitetnog razvoja softvera. U trećem poglavlju dan je uvid u različite platforme dostupne za implementaciju kontinuirane integracije. Ispitujući popularne CI/CD alate kao što su jenkins, travis CI i gitlab CI, uspoređene su njihove značajke, funkcionalnosti i mogućnosti integracije. Poglavlje četiri usredotočeno je na gitlab cjevovode, pružajući detaljan opis njegovih koncepata i kako ih učinkovito koristiti u CI/CD tijeku rada. Uz opis koncepata prikazan je tijek konfiguracije gitlab CI/CD cjevovoda na konkretnom primjeru, definirajući faze, poslove i tijekove rada. Nadalje, opisani su koraci integracije s docker hub repozitorijem kako bi se olakšao proces pokretanja aplikacije u oblaku.U petom poglavlju prikazana je implementacija web aplikacije koja koristi javu i okvir spring boot. Dan je pregled programskog jezika java i okvira spring boot. Uz opis prikazana je arhitektura i funkcionalnosti web aplikacije, ocrtavajući izbor dizajna i pristupe implementaciji. Uz implementaciju web aplikacije u ovom poglavlju pokrivena je i implementacija kontinuirane integracije i gitlab cjevovoda u proces razvoja. Postavljen je gitlab repozitorij za aplikaciju, definirana je CI/CD konfiguracija i uspostavljene su faze cjevovoda za verzioniranje, izgradnju, testiranje i pokretanje aplikacije u produkcijskoj okolini. Dodatno, istraženi su postupci automatiziranog testiranja i osiguranja kvalitete koda kako bi se osigurala robusnost i pouzdanost razvijene aplikacije. U sedmom poglavlju ocjenjeni su rezultati implementirane aplikacije, analizirajući učinkovitost kontinuirane integracije i gitlabovih cjevovoda u poboljšanju tijeka razvoja. Procjenjena je  izvedba i učinkovitost implementiranog sustava, ispitujući faktore kao što su vrijeme izrade, pokrivenost testom i stope uspješnosti implementacije.


\newpage

\section{Kontinuirana integracija}
Osobe koje nisu zaposlene u softverskim tvrtkama možda nisu svjesne sveobuhvatnog procesa uključenog u razvoj softvera izvan jednostavnog pisanja koda. Nakon što se kod pošalje na repozitorij, postoji dugačak i zamršen niz zadataka koji se moraju izvršiti da bi se izradio, potvrdio, osigurao, upakirao i implementirao softver prije nego što postane dostupan korisnicima. Ti se zadaci mogu izvršiti ručno ili, pod određenim okolnostima, u određenoj mjeri automatizirani. Međutim, i ručne i automatizirane metode pripreme softvera stvaraju određene izazove.

DevOps je nedavno nastala metodologija usmjerena na rješavanje ovih zadataka. Kombinira elemente automatizacije, suradnje, brze povratne informacije i iterativnog poboljšanja, omogućujući timovima da poboljšaju kvalitetu softvera, ubrzaju proces razvoja i smanje troškove\cite{cowell2023automating}. 
 
Rasprostranjena karakteristika brojnih softverskih projekata su produljena razdoblja tijekom razvoja u kojima aplikacija ostaje nefunkcionalna. Zapravo, značajan dio vremenskog okvira razvoja softvera koji su izradili veliki timovi provodi se u neupotrebljivom stanju. Temeljni razlog za ovaj fenomen sasvim je razumljiv: nema poticaja za pokušaj pokretanja cijele aplikacije dok se ona u potpunosti ne dovrši. Programeri doprinose promjenama i mogu provoditi automatizirana testiranja jedinica, ali se ne provode stvarno pokretanje i korištenje aplikacije u okruženju sličnom produkcijskom.

Ova je okolnost dodatno naglašena u projektima koji koriste proširene grane ili odgađaju testiranje prihvatljivosti za kasnije faze. U takvim projektima obično se značajne faze integracije vrše pred kraj razvojnog procesa, dajući razvojnom timu vremena da spoji grane i osigura da aplikacija funkcionira adekvatno za testiranje prihvaćanja. Da stvar bude složenija, određeni projekti nailaze na nesretnu spoznaju da njihov softver nije prikladan za namijenjenu svrhu tijekom integracijskog razdoblja. Ove faze integracije mogu postati iznimno dugotrajne, a što je najvažnije, njihovo trajanje ostaje nepredvidivo \cite{humble2010continuous}.

\subsection{Definicija kontinuirane integracije}
Koncept kontinuirane integracije prvi puta je predstavljen u knjizi Kenta Becka "Extreme Programming Explained", prvobitno objavljenoj 1999. Slijedeći načela ekstremnog programiranja, kontinuirana integracija proizašla je iz ideje da ako je redovita integracija baze koda korisna, zašto je ne učiniti stalnom praksom? U domeni integracije, "cijelo vrijeme" se odnosi na svaku instancu kada je izvršena bilo kakva izmjena u sustavu kontrole verzija.

Kontinuirana integracija označava značajan pomak u načinu razmišljanja. U nedostatku kontinuirane integracije, softver ostaje neispravan sve dok netko ne dokaže njegovu funkcionalnost, obično tijekom faza testiranja ili implementacije. Međutim, uz kontinuiranu integraciju, funkcionalnost softvera se provjerava (pod pretpostavkom prisutnosti odgovarajuće sveobuhvatnog paketa automatiziranih testova) sa svakom novom promjenom, a svi problemi se odmah identificiraju za trenutačnu verziju koda. Timovi koji učinkovito provode kontinuiranu integraciju mogu ubrzati isporuku softvera i naići na manje nedostataka u usporedbi s onima koji to ne čine. Otkrivanjem grešaka u ranoj fazi procesa isporuke, kada je manji trošak otkloniti ih, postižu se znatne uštede u pogledu vremena i troškova. Uslijed toga, kontinuiranu integraciju smatramo nezamjenjivom praksom za profesionalne timove \cite{humble2010continuous}.


\subsection{Izazovi implementacije kontinuirane integracije}
Kroz eksperimentalno istraživanje provedeno na Odjelu za računalne znanosti i inženjerstvo na Sveučilištu Chalmers u Göteborgu, Švedskoj, praćeno je sedam timova kroz 13 polu strukturiranih intervjua u periodu implementacije kontinuirane integracije u razvojni ciklus softvera unutar firme. Kroz provedeno istraživanje izazovi implementacije kontinuirane integracije podijeljeni su u sedam grupa prikazanih na slici \ref{f:izazovi implementacije kontinuirane integracije}.


\begin{figure}[ht!] % [ht!] - opcija koja definira polozaj slike h-here, t-top, !-ne slusaj latexov AI. 
	\centering % - centrira sliku
	\includegraphics[scale=0.44]{./Slike/izazovi implementacije kontinuirane integracije.png} % [scale] - skalira dimenziju slike, moze i [width=0.6\linewidth] i slicno. 
	\caption{izazovi implementacije kontinuirane integracije \cite{challenges} \label{f:izazovi implementacije kontinuirane integracije}} % LABEL UVIJEK UNUTAR CAPTIONA. 
\end{figure}

\subsection{Proces kontinuirane integracije}
Tijekom faze kontinuirane integracije (CI), promjene razvojnog programera spajaju se i provjeravaju kako bi se osiguralo da kod ostaje funkcionalan. Glavni cilj CI-ja je brzo provjeriti te izmjene koda i odmah obavijestiti programera o svim problemima. Ovaj proces minimizira vrijeme tijekom kojeg je baza koda neupotrebljiva uslijed novo uvedenih pogrešaka. CI otkriva promjene koda i izvršava relevantne procese izgradnje kako bi pokazao da se promjene koda mogu uspješno izgraditi. Također može provoditi ciljane testove kako bi potvrdio da promjene koda rade neovisno, pri čemu ulazi proizvode željene izlaze i identificiraju i postupaju očekivano rukovajući pogrešnim ulazima.

Kontinuirana isporuka odnosi se na niz automatiziranih procesa, poznatih kao cjevovod, koji uključuje promjene koda i izvršava izgradnju, testiranje, pakiranje i povezane operacije za generiranje verzije softvera koji se može koristiti. Općenito, to se postiže s malo ili nimalo ljudske intervencije.

Kontinuirana isporuka preuzima promjene koje je potvrdio i spojio CI i nastavlja s preostalim procesima u cjevovodu kako bi se proizveli željeni rezultati. Po izboru, može pokrenuti procese kontinuirane implementacije kako bi se izdanja automatski učinila dostupnima korisnicima. Mehanizam koji se koristi za kontinuiranu isporuku obično se naziva cjevovod kontinuirane isporuke, iako može imati i druga imena.

Iako krajnji rezultat cjevovoda često percipiramo kao ispravan kod ili softver koji se može koristiti, postoje ključni privremeni izlazi na putu. Zapravo, jedan od bitnih koraka u cjevovodu uključuje kombiniranje novopotvrđenih i spojenih promjena (iz CI-ja) s drugim kodom o kojem ovise ili s kojim trebaju raditi za generiranje artefakata. Upravljanje ovim srednjim rezultatima vrijedno je daljnjeg istraživanja.

Kontinuirano testiranje uključuje izvođenje automatiziranih testova ili drugih oblika analize koji se postupno šire kako kod napreduje kroz cjevovod kontinuirane isporuke. Neophodne su i preporučuju se različite vrste testiranja, uključujući:

\begin{itemize}
\item Unit testiranje, integrirano s procesima izgradnje tijekom CI faze, fokusira se na testiranje koda izolirano od drugog koda s kojim je u interakciji.
\item Integracijsko testiranje potvrđuje funkcioniranje grupa komponenti i usluga u kombinaciji.
\item Funkcionalno testiranje osigurava da izvršavanje funkcija u proizvodu daje očekivane rezultate.
\item Testiranje prihvatljivosti mjeri specifične karakteristike sustava prema unaprijed određenim kriterijima, kao što su performanse, skalabilnost, stres i kapacitet.
\end{itemize}

Mjerni podaci i analiza kodiranja ne spadaju u istu kategoriju kao testiranje prošao/nije prošao, ali doprinose kontinuiranom testiranju procjenom koda i kvalitete testiranja. Također se mogu koristiti kao kriteriji za pristupni (blokirajući ili dopuštajući) kod u različitim fazama cjevovoda. Neki primjeri ovih metrika i analiza uključuju:

\begin{itemize}
\item Analiza dijela koda pokrivenog testnim slučajevima, poznatog kao pokrivenost koda, koji se može mjeriti pomoću alata kao što je JaCoCo za Java kod.
\item Brojanje redaka koda, mjerenje složenosti i usporedba strukture i stila kodiranja s utvrđenim najboljim praksama, što se može postići pomoću alata kao što je SonarQube. Takvi alati provode provjere, uspoređuju rezultate sa željenim pragovima, kontroliraju daljnju obradu u cjevovodu i daju integrirana izvješća o ishodima.

\end{itemize}


Važno je napomenuti da nisu sve vrste testiranja prisutne u automatiziranom cjevovodu i mogu postojati nejasne granice između nekih od ovih kategorija testiranja. Međutim, krajnji cilj kontinuiranog testiranja unutar cjevovoda isporuke ostaje isti: postupno demonstrirati kroz testiranje i analizu da trenutna verzija koda zadovoljava potrebne standarde kvalitete.

Kontinuirana implementacija odnosi se na mogućnost preuzimanja izdanja koda koji je generirao cjevovod isporuke i automatskog stavljanja na raspolaganje krajnjim korisnicima. Ova vrsta cjevovoda često se naziva cjevovod za implementaciju. Proces implementacije može uključivati implementaciju u oblaku, ažuriranje web stranice, stavljanje ažuriranja na raspolaganje ili jednostavno ažuriranje popisa dostupnih izdanja, ovisno o tome kako bi korisnici "instalirali" softver.

Vrijedno je naglasiti da samo zato što se može postići kontinuirana implementacija ne znači da je svaki skup isporučenih rezultata iz cjevovoda uvijek implementiran ili da su nove funkcionalnosti odmah omogućene. Umjesto toga, cjevovod osigurava da je svaki skup isporučenih proizvoda dokazano sposoban za implementaciju kroz mehanizme poput kontinuiranog testiranja.

\begin{figure}[ht!] % [ht!] - opcija koja definira polozaj slike h-here, t-top, !-ne slusaj latexov AI. 
	\centering % - centrira sliku
	\includegraphics[scale=0.36]{./Slike/kontinuirana integracija, isporuka i implementacija.png} % [scale] - skalira dimenziju slike, moze i [width=0.6\linewidth] i slicno. 
	\caption{kontinuirana integracija, isporuka i implementacija \cite{ci_tools_slika} \label{f:kontinuirana integracija, isporuka i implementacija}} % LABEL UVIJEK UNUTAR CAPTIONA. 
\end{figure}

Vraćanje ili poništavanje implementacije za sve korisnike može biti skupa situacija, i tehnički i u smislu percepcije korisnika. Stoga odluka o tome treba li primijeniti oslobađanje iz cjevovoda može uključivati ljudsku prosudbu. Mogu se upotrijebiti različite metode za "testiranje" verzije aplikacije prije njegove potpune implementacije, stoga je preporuka da se posljednja verzija testira u integracijskoj okolini prije njezine implementacije za korisnike u produkcijsku okolinu.\cite{brent-2020-CI/CD} Na slici \ref{f:kontinuirana integracija, isporuka i implementacija} prikazana je razlika kontinuirane integracije, isporuke i implementacije.

\newpage

\section{Platforme za provedbu kontinuirane integracije}

 Poduzeća sve više iskazuju afinitet prema DevOps metodologijama i agilnom pristupu razvoja softvera kako bi se ubrzao razvoj i isporuka kvalitetnih softverskih rješenja. Međutim, uspjeh ovog pristupa uvelike ovisi o odabiru pravih alata za kontinuiranu integraciju koji su usklađeni sa zahtjevima i potrebama poduzeća ili projekta.

Trenutačno je dostupan širok niz platformi za implementaciju kontinuirane integracije, što menadžerima predstavlja izazov pri odabiru najprikladnije za njihove projekte. Kako bi bili sigurni da je odabrana najbolja platforma, bitno je uzeti u obzir specifične tehničke karakteristike pojedine platforme.

Prvo, idealna platforma za kontinuiranu integraciju trebala bi ponuditi robustan ekosustav koji ubrzava isporuku projekta bez stvaranja zastoja. Osim toga, trebala bi se neprimjetno integrirati s uslugama u oblaku, omogućujući prijenos podataka u oblak i iz njega bez napora. Nadalje, platforma bi trebala pružiti pouzdane mogućnosti implementacije i podržavati integraciju s drugim alatima i uslugama koje se koriste u projektu. Ključno je dati prioritet sigurnosti, osiguravajući da odabrana CI platforma ne predstavlja rizik za podatke projekta, bez obzira na to radi li se o komercijalnom ili otvorenom programskom rješenju.

Osim tehničke sofisticiranosti, bitno je da se CI platforma uskladi s projektom i potrebama tvrtke. Ovisno o poslovnoj strategiji, moguće je odlučiti se za besplatni alat otvorenog koda ili komercijalno CI rješenje. Uz to, odabrana platforma trebala bi olakšati jednostavno upravljanje projektima i prijenos podataka, a istovremeno nuditi mogućnosti vizualizacije za bolje razumijevanje sadržaja.

Uzimajući u obzir tehničke aspekte i kompatibilnost s projektom i zahtjevima tvrtke, moguće je odabrati dobro zaokruženu CI platformu koja usmjerava razvojni proces i pridonosi cjelokupnom uspjehu projekta.

\newpage

\subsection{Pregled popularnih platformi}
Postoje brojne platforme za kontinuiranu integraciju no neke od najpopularnijih su:

\begin{multicols}{2}
\begin{itemize}
\item Gitlab CI
\item Jenkins
\item CircleCI
\item TeamCity
\item Bamboo
\item Travis CI
\item Buddy
\item Codeship
\item GoCD
\item Semaphore
\end{itemize}
\end{multicols}



\subsection{Karakteristike i funkcionalnosti platformi}
GitLab CI/CD, Jenkins, CircleCI, Travis CI i TeamCity neke su od najpopularnijih CI/CD platformi koje nude opsežnu podršku i integraciju za rad s Docker kontenjerima \cite{katalon_ci_tools, atlassian_ci_tools, top_7_ci_tools}. Izbor između njih može ovisiti o čimbenicima kao što su specifični zahtjevi, preference alata i cjelokupni DevOps ekosustav u organizaciji. Činjenica da su ove platforme najpopularnije, ne znači da ostale platforme ne pružaju gotovo iste mogućnosti. U nastavku dan je pregled glavnih karakteristika i funkcionalnosti prethodno nabrojanih platformi.

\begin{enumerate}

\item 
Gitlab CI

GitLab je opsežan skup alata dizajniranih za nadgledanje različitih aspekata procesa razvoja softvera. U svojoj srži, GitLab je platforma temeljena na webu koja služi kao Git repozitorij, nudeći funkcionalnosti kao što su praćenje problema, analitika i Wiki za podršku kolaborativnom razvoju.

Jedna od bitnih značajki GitLaba je njegova sposobnost pokretanja izgradnje, izvršavanja testova i automatske implementacije koda sa svakom objavljenom promjenom. To znači da kad god se naprave promjene u bazi koda, GitLab može pokrenuti potrebne procese kako bi osigurao integritet i kvalitetu softvera. Ti se procesi mogu provesti unutar virtualnog stroja, Docker kontenjera ili na drugom poslužitelju, pružajući fleksibilnost i prilagodljivost razvojnom okruženju.

Neke od glavnih karakteristika su:
\begin{itemize}
\item GitLab je komercijalni alat i besplatni paket. Nudi hosting SaaS na GitLabu, na lokalnoj instanci i/ili u oblaku.
\item Učinkovito upravljajte pregledom, stvaranjem i upravljanjem kodom i projektnim podacima korištenjem alata za grananje.
\item Omogućuje brzu iteraciju i isporuku poslovnih vrijednosti kroz dizajn, razvoj i upravljanje kodom i projektnim podacima unutar objedinjenog distribuiranog sustava kontrole verzija.
\item Pouzdana i skalabilna platforma koja služi kao mjerodavan izvor za suradnju na projektima i kodu, osiguravajući jedinstveni izvor istine.
\item Olakšava usvajanje CI praksi od strane timova za isporuku kroz automatizaciju procesa izgradnje, integracije i verifikacije izvornog koda.
\item Omogućuje isporuku sigurnih aplikacija i usklađenost sa zahtjevima licenciranja pružanjem skeniranja repozitorija, testiranja sigurnosti statičke aplikacije (SAST), testiranja sigurnosti dinamičke aplikacije (DAST) i skeniranja ovisnosti.
\item Automatiziranje i pojednostavljeno izdavanje i isporuka aplikacija, smanjujući ručne napore i ubrzavajući proces implementacije.
\end{itemize}

\item 
Jenkins

Jenkins je besplatno dostupan poslužitelj za automatizaciju zadataka, poput izgradnje i kontinuirane integracije, u području razvoja softvera. Razvijen u Javi i sposoban za rad na različitim operativnim sustavima kao što su Windows, macOS i sustavima sličnim Unixu, Jenkins je opremljen širokim rasponom dodataka koji olakšavaju izgradnju, implementaciju i automatizaciju softverskih projekata.

Neke od glavnih karakteristika su:
\begin{itemize}
\item Jenkins je alat otvorenog koda s aktivnom zajednicom.
\item Jednostavna instalacija i nadogradnje na različitim operacijskim sustavima.
\item Sučelje je jednostavno i prilagođeno korisniku.
\item Jenkins se može proširiti velikom zbirkom dodataka koje je pridonijela zajednica.
\item Konfiguraciju okruženja lako je postaviti unutar korisničkog sučelja.
\item Jenkins podržava distribuiranu izgradnju kroz master-slave arhitekturu.
\item Rasporedi izrade mogu se prilagoditi na temelju izraza.
\item Podržava pokretanje shell i Windows naredbi u koracima prije izgradnje
\item Korisnici mogu primati obavijesti o statusu izgradnje.
\end{itemize}

\item 
CircleCI 

CircleCI je CI/CD alat koji olakšava brz razvoj i procese izdavanja softvera. Omogućuje automatizaciju u različitim fazama korisničkog cjevovoda, uključujući kompilaciju koda, testiranje i implementaciju.

Integracijom CircleCI-ja s platformama kao što su GitHub, GitHub Enterprise i Bitbucket, korisnici mogu pokrenuti izgradnju kad god se izvrše nove promjene koda. CircleCI nudi fleksibilnost hostinga kontinuirane integracije bilo u postavkama kojima upravlja oblak ili ih pokreće interno iza vatrozida na privatnoj infrastrukturi.

Neke od glavnih karakteristika su:
\begin{itemize}
\item Linux planovi počinju s opcijom pokretanja jednog posla bez paralelizma bez naknade. Projekti otvorenog koda dobivaju tri dodatna besplatna kontenjera. Tijekom prijave prikazane su cijene kako bi se korisnici odlučili koji plan(ove) trebaju.
\item Integracija je dostupna s Bitbucketom, GitHubom i GitHub Enterpriseom.
\item Izgradnje koda se mogu izvršiti pomoću kontenjera ili virtualnih strojeva.
\item Jednostavno otklanjanje pogrešaka.
\item Dostupne su mogućnosti automatizirane paralelizacije.
\item Brzi procesi testiranja.
\item Personalizirane obavijesti mogu se slati putem e-pošte i izravnih poruka.
\item Podržava kontinuiranu implementaciju, uključujući implementacije specifične za git grane.
\item Visoka razina prilagodbe.
\item Dostupno je automatsko spajanje i mogućnost izvršavanja prilagođenih naredbi za učitavanje paketa.
\item Proces postavljanja je brz i nema ograničenja u broju nadogradnji koje se mogu izvesti.
\end{itemize}

\item 
Travis CI

Travis CI je usluga specijalizirana za izgradnju i testiranje projekata kroz kontinuiranu integraciju. Integracijom s GitHub repozitorijem, Travis CI automatski identificira nove izmjene koda nakon čega pokreće izgradnju projekta i izvršava odgovarajuće testove i zadatke.

Travis CI nudi opsežnu podršku za različite konfiguracije izgradnje koda i programske jezike, uključujući, ali ne ograničavajući se na Node, PHP, Python, Javu i Perl.

Neke od glavnih karakteristika su:
\begin{itemize}
\item Travis CI je hosted CI/CD usluga. Privatni projekti mogu se testirati na travis-ci.com uz naknadu. Projekti otvorenog koda mogu se besplatno prijaviti na travis-ci.org
\item Proces postavljanja je brz i jednostavan.
\item Projekti na GitHub-a mogu se pratiti prikazom izgradnje uživo.
\item Podržani su zahtjevi za spajanje koda iz grane u granu.
\item Implementacija se može izvršiti na više usluga u oblaku.
\item Dostupne su unaprijed instalirane usluge baze podataka.
\item Automatske implementacije pokreću se nakon uspješne izgradnje koda.
\item Svaka izgradnja radi na čistom virtualnom računalu.
\item Podržava macOS, Linux i iOS platforme.
\item Podržano je više programskih jezika, uključujući Android, C, C\#, C++, Java, JavaScript (s Node.js), Perl, PHP, Python, R, Ruby i brojni drugi.
\end{itemize}

\item 
TeamCity

TeamCity, razvio je JetBrains, poslužitelj je za upravljanje izgradnjom i kontinuiranom integracijom. Služi kao vrijedan alat za izgradnju i implementaciju različitih vrsta projekata. TeamCity radi unutar Java okruženja i lako se integrira s Visual Studiom i ostalim IDE-ima. Ovaj svestrani alat može se instalirati na Windows i Linux poslužitelje, prilagođavajući se potrebama .NET i open-stack projekata.

U svojoj verziji 2019.1 TeamCity predstavlja novo korisničko sučelje zajedno s izvornom integracijom za GitLab. Također proširuje svoju podršku za GitLab i Bitbucket zahtjeve spajanja koda iz grane u granu. Osim toga, ovo izdanje uključuje značajke kao što su autentifikacija na temelju tokena, otkrivanje i izvješćivanje o Go testovima, kao i mogućnost rukovanja zahtjevima na AWS Spot Fleet.

Neke od glavnih karakteristika su:
\begin{itemize}
\item TeamCity je komercijalni alat s besplatnim i vlasničkim licencama.
\item Nudi različite metode za primjenu postavki i konfiguracija nadređenog projekta na podprojekte, promičući ponovnu upotrebu.
\item Podržava paralelne izgradnje koda u više okruženja, omogućujući istovremeno izvođenje.
\item Omogućuje značajke kao što su pregled izvješća o povijesti testiranja, prikvačivanje, označavanje i dodavanje međuverzija u favorite za učinkovito praćenje i upravljanje povijesti verzija.
\item Poslužitelj je visoko prilagodljiv, interaktivan i proširiv, što omogućuje prilagođene konfiguracije.
\item Osigurava funkcionalnost i stabilnost CI poslužitelja, promičući neometan rad.
\item Nudi fleksibilno upravljanje korisnicima, omogućava dodjelu korisničkih uloga, grupiranje korisnika, višestruke metode provjere autentičnosti i održavanje dnevnika radnji korisnika za transparentno praćenje aktivnosti poslužitelja.
\end{itemize}

\end{enumerate}

\subsection{Odabir najprikladnije platforme za implementaciju}

Pri odabiru platforme za implementaciju kontinuirane integracije, za aplikaciju implementiranu u sklopu ovoga rada, Jenkins i Gitlab platforme su bile glavni kandidati. I Jenkins i GitLab nude vrijedne značajke u svojim domenama. Jenkins pruža opsežnu jezičnu podršku i može se pohvaliti golemom bibliotekom dodataka. Njegovo korisničko sučelje pojednostavljuje zadatke kao što su postavljanje čvora, otklanjanje pogrešaka pokretača i implementacija koda. Alat je vrlo prilagodljiv, što omogućuje fleksibilno uređivanje konfiguracije. Budući da se samostalno hosta, Jenkins korisnicima pruža veću kontrolu nad radnim prostorima te je upravljanje pristupom jednostavno.
Međutim, Jenkins zaostaje kada je u pitanju analitika praćenja cjevovoda, što može biti nedostatak. Osim toga, konfiguriranje integracije dodataka i postavljanje alata može oduzimati puno vremena, otežavajući proces implementacije kontinuirane integracije.

S druge strane, GitLab služi kao sveobuhvatan DevOps alat koji obrađuje različite razvojne zadatke. Dolazi opremljen ugrađenim Git sustavom za kontrolu verzija, što olakšava integraciju s drugim rješenjima.

Jedna značajka GitLaba vrijedna pažnje je njegova sposobnost pružanja poslovnih uvida, nudeći jasnu vidljivost utjecaja promjena na performanse proizvoda. Statistika korisnika pomaže u praćenju korištenja resursa i optimizaciji procesa, no ova je značajka dostupna samo korisnicima koji plaćaju za Gitlab CI usluge. Praćenje problema je još jedna vitalna sposobnost, podržana značajkama kao što su rasprave u nitima, oznake i popisi zadataka, omogućujući učinkovito praćenje i dodjelu problema za brzo rješavanje. GitLab također omogućuje uvoz zadataka iz JIRA-e. Upravljanje spajanjem koda iz grane u granu olakšava suradnju i kontrolu verzija projekata.

GitLab se ističe u omogućavanju paralelnog izvođenja kroz faze, pojednostavljujući skaliranje pokretača. Dodavanje poslova i rješavanje konflikta u kodu je vrlo jednostavno. Alat daje prioritet sigurnosti projekta s odgovarajućim pravilima o privatnosti i neprimjetno se integrira s Dockerom.

S negativne strane, GitLab uvodi neke složenosti i napor, jer definiranje i rukovanje artefaktima za svaki posao postaje neophodno. Testiranje spojenog stanja iz grane u granu zahtijeva da se stvarno spajanje dovrši prije, stoga je bitno da razvojni programeri prije spajanja svog koda u main granu, spoje grane lokalno i tako spojen kod pošalju na git.

Iako GitLab uvodi neke složenosti, poput definiranja i rukovanja artefaktima za svaki posao, njegove sveobuhvatne značajke i mogućnosti integracije s docker registrima čine ga prikladnijim za kreiranu aplikaciju. Naravno, to ne znači da je Jenkins ili bilo koja druga platforma lošiji odabir, veliku ulogu u odabiru imala je i upoznatost s Gitlab cjevovodima kroz prijašnji rad i iskustvo.


\section{Gitlab pipeline koncepti i primjena}

Cjevovodi se najjednostavnije mogu objasniti kao niz automatiziranih shell naredbi, minimizirajući potrebu za ljudskim sudjelovanjem. Razumijevanje ovog temeljnog koncepta ključno je za razumijevanje CI/CD cjevovoda. Drugim riječima, CI/CD cjevovod može se opisati kao lanac naredbi koje izvršava robot i koje obuhvaćaju zadatke povezane s izgradnjom softvera, testiranjem i implementacijom.

Izvršenje ovih naredbi provode GitLab Runneri, robotski entiteti u procesu. Iz tehničke perspektive, GitLab Runner je kompaktni program koji prima naredbe od GitLab instance i izvršava ih u skladu s tim. Moguće je koristiti besplatni, zadani Gitlab runner koji nije potrebno dodatno konfigurirati, no također je moguća instalacija vlastite instance Gitlab runnera na virtualnom stroju.

Svaki put kada se cjevovod projekta izvede, on radi na određenoj verziji datoteka projekta. To implicira da se tijekom CI faze cjevovoda automatizirani testovi i skeniranja provode na jednoj verziji datoteka. Nakon toga, u fazi CD-a, ista verzija datoteka se postavlja u odgovarajuće okruženje. Ovaj se koncept također može izraziti kao cjevovod koji radi "protiv" određene verzije datoteka projekta.

Svrha cjevovoda je procijeniti stanje koda i implementirati ga kad god se naprave promjene. Posljedično, pokretanje cjevovoda projekta na kodu od prethodnog dana dalo bi poseban skup rezultata u usporedbi s pokretanjem s kodom iz tekućeg dana, čak i ako se cjevovod sastoji od identičnih faza, poslova i naredbi. Razlika u rezultatima nastaje zbog mogućih čimbenika kao što je dodavanje novih automatiziranih testova, uvođenje softverskih grešaka koje dovode do neuspjeha testa ili uključivanje ovisnosti sa sigurnosnim propustima. Imajući to u vidu, dva pokretanja cjevovoda generirala bi suprotne ocjene u pogledu kvalitete koda.

\subsection{Faze i zadatci u gitlab pipelineu}
Svaki cjevovod se sastoji od jedne ili više faza, koje su skupine povezanih zadataka. Tri najčešće korištene faze su sljedeće:
\begin{enumerate}
\item Izgradnja: Ova faza sadrži zadatke koji kompiliraju i pakiraju izvorni kod u format koji se može primijeniti.

\item Testiranje: Ova faza obuhvaća zadatke koji izvršavaju automatizirane testove, skeniranje kvalitete koda, linting i potencijalno sigurnosno skeniranje.

\item Implementacija: Ova faza je odgovorna za slanje koda u odgovarajuće okruženje na temelju Git grane ili oznake prema kojoj se cjevovod pokreće. 
\end{enumerate}

Ove tri faze unaprijed su konfigurirane u GitLabovim zadanim postavkama cjevovoda. Međutim, gitlab pruža fleksibilnost mijenjanja ove zadane konfiguracije dodavanjem, uklanjanjem ili zamjenom faza. Bez obzira na odabrane faze, preporuka je da ih se eksplicitno definira, čak i ako je krajnja odluka korištenje zadane tri faze. Iako se ovo može činiti opširnim, poboljšava čitljivost, pomaže u rješavanju problema i sprječava zabune u budućnosti.

Ne postoji ograničenje broja faza koje je moguće definirati. Čak i za vrlo jednostavne projekte, možemo stvoriti pojednostavljeni cjevovod sa samo jednom fazom. Imena faza mogu se birati slobodno, dopuštajući razmake i razne interpunkcijske simbole. Kako bi se osigurala čitljivost, predlaže se da imena faza budu što  sažetija, bez žrtvovanja jasnoće, jer duga imena mogu biti skraćena u GitLabovom grafičkom korisničkom sučelju.

Važno je napomenuti da GitLab ne provjerava tematsku vezu između zadataka unutar faze; ova odgovornost leži na osobi koja ih implementira. Posljedično, postoji sloboda kreiranja neorganiziranog i neorganiziranog cjevovoda. Na primjer, moguće je pokrenuti automatizirane regresijske testove u fazi pod nazivom "Primjena dokumentacije" ili implementirati dokumentaciju u fazi pod nazivom "priprema-testnog okruženja". Podjela cjevododa u faze i dodjela zadataka svakoj fazi u potpunosti je na osobi koja vrši implementaciju. Smatra se najboljom praksom povremeno pregledavanje i refaktoriranje strukture cjevovoda kako bi se osigurala jasnoća i dosljednost.


Kada su u pitanju komponente GitLab CI/CD cjevovoda, poslovi se mogu promatrati kao sljedeća razina ispod faza. Svaki stupanj sadrži jedan ili više poslova, a svaki posao pripada određenom stupnju.

\begin{figure}[ht!] % [ht!] - opcija koja definira polozaj slike h-here, t-top, !-ne slusaj latexov AI. 
	\centering % - centrira sliku
	\includegraphics[scale=0.5]{./Slike/gitlab ci job overview main branch.png} % [scale] - skalira dimenziju slike, moze i [width=1\linewidth] i slicno. 
	\caption{prikaz Gitlab posla s pripadajućim fazama \label{f:prikaz Gitlab posla s pripadajućim fazama}} % LABEL UVIJEK UNUTAR CAPTIONA. 
\end{figure}

Gledajući sliku zaslona \ref{f:prikaz Gitlab posla s pripadajućim fazama}, možemo uočiti da faza izgradnje uključuje posao pod nazivom build-job, faza testiranja uključuje posao pod nazivom test-job, a faza Deploy uključuje posao pod nazivom deploy-job.

Kao što pokazuju ovi nazivi poslova, obično je svaki posao odgovoran za obavljanje određenog zadatka. Na primjer, posao bi mogao kompajlirati Java izvorni kod u klase, drugi posao bi mogao resetirati podatke testne baze podataka, a još jedan posao bi mogao gurnuti Docker sliku u registar. Međutim, baš kao što GitLab ne provodi tematsku sličnost poslova unutar faza, također ne potvrđuje ispunjavaju li poslovi stvarno zadatak koji sugeriraju njihova imena. Drugim riječima, imate slobodu kreirati posao pod nazivom compile-java koji briše zalutale datoteke generirane automatiziranim testovima ili posao pod nazivom deploy-to-production koji pokreće sigurnosni skener. Stoga je važno biti oprezan i promišljen pri imenovanju svojih poslova, povremeno ih pregledavajući kako biste osigurali točnost i čitljivost.

Osim toga, GitLab ne nameće zahtjev da svaki posao obavlja samo jedan zadatak. To znači da vas ništa ne sprječava da napravite posao pod nazivom test koji izvršava višestruke automatizirane pakete testova, testove performansi i sigurnosne skenere. Međutim, smatra se najboljom praksom svaki posao fokusirati na jedan zadatak. GitLab vam omogućuje kreiranje poslova s različitim opsegom, širokim ili uskim, u skladu s vašim specifičnim potrebama.


\subsection{Definiranje gitlab CI/CD konfiguracije}

U prethodnom poglavlju definiran je proces konfiguriranja CI/CD cjevovoda, koji uključuje definiranje faza, poslova i naredbi, no kako zapravo izvesti ovu konfiguraciju i gdje? Sva konfiguracija za CI/CD cjevovod obavlja se unutar datoteke pod nazivom .gitlab-ci.yml, koja se nalazi u korijenskom direktoriju repozitorija projekta. Ako istražimo bilo koji javni GitLab projekt s implementiranim cjevovodom, možemo pronaći datoteku s ovim nazivom koja određuje radnje konfigurirane za taj projekt.

Svaka datoteka .gitlab-ci.yml koristi jezik YAML(yet another markup language ili YAML ain't markup language) dizajniran za tu svrhu. Ovaj se jezik sastoji od ključnih riječi, vrijednosti i nekih sintaktičkih elemenata. Određene ključne riječi koriste se za definiranje faza i poslova unutar tih faza. Ostale ključne riječi koriste se za prilagodbu poslova i njihovog ponašanja unutar cjevovoda. Dodatno, postoje ključne riječi za postavljanje varijabli, određivanje Docker slika za poslove i utjecaj na cjelokupni cjevovod na različite načine. Ovaj jezik je dovoljno fleksibilan da se prilagodi širokom rasponu zadataka u CI/CD cjevovodima, ali ipak nije pretjerano složen (barem nakon što se stekne neko iskustvo u pisanju i razumijevanju ovih CI/CD konfiguracijskih datoteka).

Postoji otprilike 30 ključnih riječi dostupnih za korištenje u datoteci .gitlab-ci.yml. Umjesto pamćenja svih pojedinosti i opcija konfiguracije povezane sa svakom ključnom riječi, preporuča se usredotočavanje na shvaćanje ukupnih mogućnosti koje nude CI/CD cjevovodi. Nakon shvaćanja općih mogućnosti, lakše je upoznati se sa specifičnim ključnim riječima prema potrebi. Službena dokumentacija GitLaba najpouzdaniji je izvor informacija o ključnim riječima, osobito jer se one mogu mijenjati tijekom vremena.

\subsection{Docker i povezivanje s dockerom za kontejnerizaciju aplikacije}

Docker ekosustav potaknuo je uspješnu zajednicu koja se sastoji od programera i administratora sustava. Slično pokretu DevOps, ova je zajednica prepoznala vrijednost rješavanja operativnih izazova putem koda, što je dovelo do razvoja poboljšanih alata. U slučajevima kada Dockerov izvorni alat zakaže, razne tvrtke i pojedinci su preuzeli inicijativu da popune te nedostatke pa tako primjerice Gitlab ima dostupan vlastiti Docker registar u koji se mogu spremati kontenjerizirane verzije aplikacije. Mnogi Docker alati su otvorenog koda, što omogućuje njihovo proširenje i prilagodbu drugim organizacijama kako bi zadovoljile svoje specifične zahtjeve. 

Docker se može podijeliti u dvije glavne komponente: klijent i poslužitelj/daemon. Dodatno, postoji izborna treća komponenta koja se zove registar, koja služi kao pohrana Docker slika i njihovih metapodataka. Poslužitelj/daemon odgovoran je za kontinuirane zadatke izgradnje, pokretanja i upravljanja spremnicima, dok se klijent koristi za davanje uputa poslužitelju o radnjama koje treba izvršiti. Docker demon se može instalirati na više poslužitelja unutar infrastrukture, a jedan klijent može komunicirati s više poslužitelja. Klijenti djeluju kao glavni pokretači komunikacije, ali Docker poslužitelji također mogu izravno komunicirati s registrima slika prema uputama klijenta. U tom kontekstu, klijenti su odgovorni za izdavanje uputa poslužiteljima, dok su poslužitelji prvenstveno usredotočeni na hosting i upravljanje kontejnerskim aplikacijama.

\begin{figure}[ht!] % [ht!] - opcija koja definira polozaj slike h-here, t-top, !-ne slusaj latexov AI. 
	\centering % - centrira sliku
	\includegraphics[scale=0.5]{./Slike/docker klijent-server model.png} % [scale] - skalira dimenziju slike, moze i [width=0.6\linewidth] i slicno. 
	\caption{Docker klijent/server model \cite{kane2023docker} \label{f:docker klijent/server model}} % LABEL UVIJEK UNUTAR CAPTIONA. 
\end{figure}

Docker ima jedinstvenu strukturu u usporedbi s nekim drugim klijent/poslužitelj softverima. Sastoji se od docker klijenta i dockerd poslužitelja. Međutim, umjesto da bude potpuno monolitan, poslužitelj koordinira razne druge komponente u pozadini u ime klijenta. Jedna od tih komponenti je containerd-shim-runc-v2, koja olakšava interakciju s runc i containerd. Unatoč ovim temeljnim složenostima, Docker pojednostavljuje proces pružanjem jednostavnog sučelja klijenta i poslužitelja, prikazanog na slici \ref{f:docker klijent/server model}. U većini slučajeva može ga se shvatiti kao jednostavnog klijenta i poslužitelja. Tipično, svaki Docker host pokreće jedan Docker poslužitelj koji može upravljati s više kontenjera. Za komunikaciju s poslužiteljem moguće je koristiti command-line alat docker, bilo izravno sa samog poslužitelja ili, ako je prikladno osiguran, s udaljenog klijenta.

Command-line alat Docker pruža oznaku izgradnje koja omogućuje korištenje Dockerfilea za izradu Docker slike. Svaka uputa unutar Dockerfilea pridonosi novom sloju unutar slike, čineći jednostavnim razumijevanje radnji koje se izvršavaju pogledom u Dockerfile. Značajna prednost ove standardizacije je da svaki inženjer koji ima iskustva s Dockerfileom može lako modificirati proces izgradnje za različite aplikacije. Zbog standardizirane prirode Docker slika, alati uključeni u izgradnju ostaju dosljedni, bez obzira na programski jezik, osnovnu sliku ili broj uključenih slojeva. Obično se Docker datoteke pohranjuju u sustavima za kontrolu revizija, što pojednostavljuje praćenje promjena u izradi.

U modernim višestupanjskim Docker izgradnjama moguće je odvojiti okruženje za izradu od konačne slike artefakta. Ovo odvajanje nudi široku konfiguraciju za okruženje izgradnje, slično konfiguracijskim mogućnostima dostupnim za proizvodne spremnike.

Mnoge izgradnje Dockera izvode se jednim pozivanjem naredbe za izgradnju slike dockera, što rezultira jednim artefaktom, naime slikom kontenjera. Budući da je većina logike izgradnje obično sadržana unutar samog Dockerfilea, postaje jednostavno stvoriti standardizirane poslove izgradnje koje mogu koristiti različite platforme u sustavima izgradnje kao što je Jenkins. Osim toga, brojne tvrtke, uključujući eBay, prihvatile su standardizaciju Linux kontenjera za izradu slika pomoću Dockerfilea. SaaS platforme za izgradnju kontinuirane integracije kao što su Travis CI i CodeShip također nude robusnu podršku za Docker gradnje, integrirajući ih kao temeljne značajke svojih usluga.

\newpage

\section{Implementacija web aplikacije i kontinuirane integracije pomoću gitlab pipelinea u razvoju aplikacije}

Kreirana aplikacija s pripadajućom gitlab-ci.yaml datotekom koja sadrži konfiguraciju cjevovoda nalazi se na gitlabu na sljedećoj poveznici: https://gitlab.com/tarantulas/file-management. 

 Za izradu web aplikacije kojoj je konfigurirana kontinuirana integracija, korištenjem gitlab cjevovoda, korišten je Spring Boot okvir. Spring Boot pruža pomoć u upravljanju ovisnostima projekta kroz koncept "početnih ovisnosti" \cite{walls2016spring}. Ove početne ovisnosti funkcioniraju kao jedinstvene Maven (i Gradle) ovisnosti, iskorištavajući mehanizam tranzitivnog rješavanja ovisnosti za prikupljanje često korištenih biblioteka pod nekoliko odabranih ovisnosti specifičnih za značajke.\cite{springBootInAction} Za izradu aplikacije korišten je Apache Maven, koji je okvir za upravljanje projektima otvorenog koda, temeljen na standardima koji pojednostavljuju izgradnju, testiranje, izvješćivanje i pakiranje projekata. Maven naredbe pokreću se kroz komandnu liniju, što je bitno za mogućnost konfiguracije cjevovoda \cite{springBootInAction}. Implementacija kreirane aplikacije nalazi se na gitlab repozitoriju na linku: https://gitlab.com/tarantulas/file-management.

\subsection{Pregled i opis jave i spring boot frameworka}

Više od desetljeća, Spring Framework se pozicionirao kao dominantan okvir za razvoj Java aplikacija, postavši glavni izbor. Spring se u početku pojavio kao lakša alternativa Java Enterprise Editionu (JEE, također poznata kao J2EE), odstupajući od složenog pristupa razvoja teških Enterprise JavaBeansa (EJB). Umjesto toga, Spring je prihvatio jednostavniju rutu za poslovni razvoj Java aplikacija, koristeći ubrizgavanje ovisnosti i aspektno orijentirano programiranje za repliciranje EJB mogućnosti korištenjem običnih Java objekata (POJO).

Međutim, unatoč pojednostavljenim komponentama koda, Spring se suočio sa zamršenostima u pogledu konfiguracije. U početku je XML služio kao konfiguracijski medij za Spring (i to u znatnim količinama). Pojavom Spring 2.5 uvedeno je skeniranje komponenti putem komentara, značajno smanjujući potrebu za eksplicitnom XML konfiguracijom u internim komponentama aplikacije. Naknadno izdanje Spring 3.0 uvelo je konfiguraciju, temeljenu na Javi, za organizacijsku alternativu XML-u i koju je lako moguće refaktorirati.
Ipak, izbjeći konfiguracijske zahtjeve pokazalo se nedostižnim. Eksplicitna konfiguracija, bilo u XML-u ili Javi, ostala je neophodna za aktiviranje specifičnih Spring funkcionalnosti kao što su upravljanje transakcijama i Spring MVC. Uključivanje značajki iz vanjskih biblioteka, kao što su web prikazi temeljeni na Thymeleafu, također je zahtijevalo eksplicitno postavljanje. Konfiguracija servleta i filtara (kao što je Springov DispatcherServlet) zahtijevala je eksplicitne konfiguracijske korake unutar web.xml ili inicijalizatora servleta. Dok je skeniranje komponenti smanjilo opseg konfiguracije, a konfiguracija Jave učinila je manje glomaznom, Spring je nastavio nametati značajne troškove konfiguracije. Vrijeme uloženo u izradu konfiguracije umanjuje raspodjelu napora prema stvarnoj logici aplikacije. Nadalje, nadziranje upravljanja ovisnosti o projektu ostaje često podcijenjen pothvat. Određivanje odgovarajućih biblioteka za uključivanje u izgradnju projekta već je složen zadatak. Međutim, točno mjerenje koje su verzije tih biblioteka kompatibilne jedna s drugom predstavlja još zastrašujući izazov. Upravljanje ovisnošću, koliko god bilo vitalno, predstavlja dodatni sloj opstrukcije. Kada uvedete ovisnosti u svoju izgradnju projekta, to znači da se vrijeme odvaja od razvoja koda aplikacije. Neuspjesi koji proizlaze iz potencijalnih nedosljednosti koje proizlaze iz netočnog odabira verzija ovisnosti mogu značajno ugroziti produktivnost. U ovom krajoliku, Spring Boot je donio transformativnu promjenu.\cite{springBootInAction}

\subsection{Arhitektura web aplikacije}

Aplikacija je kreirana koristeći Spring MVC obrazac. Spring Web model-view-controller (MVC) okvir dizajniran je oko DispatcherServleta koji šalje zahtjeve rukovateljima, s konfigurabilnim mapiranjem rukovatelja, postavkama pogleda, lokalizacijom i postavkama teme kao i podrškom za učitavanje datoteka. Zadani rukovatelj temelji se na anotacijama @Controller i @RequestMapping, nudeći širok raspon fleksibilnih metoda rukovanja komunikacijom s klijentom. S uvođenjem Spring 3.0, mehanizam @Controller također vam omogućuje stvaranje RESTful web stranica i aplikacija, putem @PathVariable anotacije i drugih značajki.\cite{spring-mvc-url} 


\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Slike/AppArchitecture.png}
    \caption{Dijagram arhitekture web aplikacije}
    \label{fig:app-architecture}
\end{figure}

Na slici \ref{fig:app-architecture} prikazana je međuovisnost glavnih dijelova spring boot arhitekture na primjeru kreirane aplikacije. Spring boot arhitektura razvoja aplikacije razdvaja aplikaciju u četiri sloja , prikazana na slici \ref{fig:dijagram-arch-apk}. Prvi je sloj baze podataka, nakon njega slijedi sloj repozitorija. U sloju repozitorija JPA (Java Persistence API) omogućuje lakšu komunikaciju s bazom podataka dajući gotove metode za manipulaciju podatcima u bazi. Uz predefinirane metode omogućuje lako pisanje vlastitih metoda uz definiciju Query naredbe koristeći anotaciju @Query. Poslovni sloj bavi se logikom rada aplikacije, ovdje se nalazi izvršavanje kalkulacija, dohvaćanje podataka iz baze kroz repozitorij i autorizacija. Posljednji, sloj Spring Boot arhitekture je prezentacijski sloj. U posljednjem sloju definira se kontroler aplikacije i pristupne točke za komunikaciju sa Spring Boot aplikacijom.



\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{Slike/springMvcLogic.png}
    \caption{Prikaz slojeva Spring Boot arhitekture \cite{springArchitectureLayers}}
    \label{fig:dijagram-arch-apk}
\end{figure}




\subsection{Implementacija funkcionalnosti backend aplikacije}

Aplikacija ima definirane CRUD (skraćenica engleskog kreiraj, dohvati, izmijeni, obriši) servise za upravljanjem podatcima korisnika, tarantula i slika. U nastavku je dan kod implementacije UserController klase koja predstavlja prezentacijski sloj aplikacije za rad s podatcima korisnika. Kod UserController.java klase, u kojem se nalazi definicija REST pristupnih točaka dan je u prilogu 1.




Na danom primjeru kontrolera bitno je obratiti pažnju na anotacije metoda i same klase. Kontroler klasa označava se @RestController anotacijom. Na primjeru je moguće uočiti @Operation anotaciju za generiranje swagger dokumentacije, @SecurityRequirements i mapping anotacije kojima se definira RESTfull mrežni servis. U kontroler korisničkim podatcima korištenjem loombok anotacije @RequiredArgsConstructor radi se ubrizgavanje ovisnosti UserService (poslovnog sloja) kroz konstruktor.

Za implementirane REST pristupne točke konfigurirana je swagger dokumentacija. Za generiranje dokumentacije, u aplikaciji je potrebno konfigurirati OpenAPI klasu. Kreirana konfiguracija dana je u prilogu 6. Nakon konfiguracije, na http://localhost:8080/swagger-ui/index.html moguće je vidjeti generiranu dokumentaciju i testirati kreirane funkcionalnosti. Snimka zaslona dokumentacije pristupnih točaka za upravljanje podatcima prikazana je na slici \ref{fig:swagger-ui}. Primjer poziva pristupne točke za generiranje autentifikacijskog tokena, korištenjem korisničkog imena i lozinke, dan je na slici \ref{fig:swagger-api-call}.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Slike/swagger-ui.png}
    \caption{Prikaz obrasca za kreiranje gitlab projekta}
    \label{fig:swagger-ui}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Slike/swagger-api-call.png}
    \caption{Prikaz poziva i odziva pristupne točke za generiranje tokena, korištenjem swagger dokumentacije.}
    \label{fig:swagger-api-call}
\end{figure}

\subsection{Postavljanje gitlab repozitorija za aplikaciju}

Pri kreiranju projekta na gitlab korisničkom sučelju moguće je odabrati opciju za kreiranje novog repozitorija. Klikom za gumb za izradu novog repozitorija otvara se obrazac, prikazan na slici \ref{fig:git-create-blank}, koji je potrebno popuniti željenim podatcima.

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Slike/git-create-blank-project.png}
    \caption{Prikaz obrasca za kreiranje gitlab projekta \cite{springArchitectureLayers}}
    \label{fig:git-create-blank}
\end{figure}

Nakon kreiranog repozitorija, moguće ga je klonirati na lokalno računalo, ili koristiti gitlab IDE za razvoj aplikacije. Gitlab posjeduje zadani gitlab-runner, no za potrebe projekta kreiran je vlastiti gitlab-runner na Google cloud vitualnoj mašini koji će se koristiti za izvođenje kontinuirane implementacije. Upute kreiranja gitlab-runnera moguće je pronaći u službenoj gitlab dokumentaciji na linku: https://docs.gitlab.com/runner.  

Vrlo korisna mogućnost gitlaba je kreiranje varijabli. Na slici \ref{fig:git-variables} prikazano je sučelje za upravljanje gitlab CI/CD varijablama. Varijable se mogu koristiti za pohranu osjetljivih informacija, kao što su lozinke i tajni ključevi, i moguće ih je koristiti u gitlab-ci konfiguraciji. Varijable se mogu klasificirati u tri vrste: zaštićene, maskirane i proširene.
\begin{itemize}
    \item Zaštićene varijable izložene su samo zaštićenim granama ili zaštićenim oznakama. To znači da neće biti vidljive korisnicima koji nisu ovlašteni za pregled zaštićenih grana ili oznaka.
    \item Maskirane varijable skrivene su u zapisnicima poslova. To znači da će biti zamijenjeni zvjezdicama u zapisnicima poslova, što ih čini nečitljivima. Maskirane varijable također moraju odgovarati zahtjevima maskiranja, što su pravila koja određuju koliko su osjetljive informacije maskirane.
    \item Proširene varijable su varijable sa znakom dolara (\$) na početku. Te se varijable tretiraju kao početak reference na drugu varijablu. Na primjer, varijabla \$DB\_PASSWORD bi se proširila na vrijednost varijable DB\_PASSWORD.
\end{itemize}


\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Slike/gitlab-variables.png}
    \caption{Prikaz konfiguriranih gitlab CI/CD varijabli korištenih u projektu}
    \label{fig:git-variables}
\end{figure}

\subsection{Definiranje gitlab ci/cd konfiguracije za aplikaciju}

Gitlab ci/cd konfiguracija definira se u gitlab-ci.yaml datoteci smještenoj u korjenskoj mapi projekta. U prilogu 2 prikazan je gitlab-ci.yaml kod konfiguracije.


Na početku konfiguracijske datoteke prvo se konfiguriraju ovisnosti, u ovom slučaju dodana je skripta otvorenog koda, korištena za verzioniranje aplikacije, koju je moguće pronaći na linku: https://gitlab.com/base58-public/ci/templates/-/blob/main/Jobs/Auto-Versioning.yml. Nakon dodavanja ovisnosti, definiran je docker kontenjer koji sadrži instaliran docker servis kako bismo unutar njega mogli pokrenuti druge docker kontenjere tijekom izvršavanja cjevovoda. Na primjeru konfiguracije korišten je docker:19.03.12−dind kontenjer unutar kojeg se za korištenje maven naredbi pokreće maven:3.8.3−openjdk−17 kontenjer čija je verzija definirana varijablom. Prije opisa pojedinog koraka izvođenja cjevovoda potrebno je navesti korake pod stages definicijom unutar yaml datoteke. U primjeru definirano je pet koraka izvođenja cjevovoda aplikacije. Definirani su koraci za izgradnju aplikacije, pokretanje testova, verzioniranje apliakcije, pakiranje i implementaciju. 


\subsection{Testiranje, izgradnja i objavljivanje aplikacije putem gitlab pipelinea}

\begin{itemize}

\item Korak za izgradnju aplikacije pokreće maven docker kontenjer unutar kojeg se izvrši naredba mvn package −B −Dmaven.test.skip=true kojom maven aplikaciju izgradi, zapakira i spremi u mapu target. U koraku izgradnje i pakiranja aplikacije isključen je korak testiranja.

\item Korak pokretanja testova pokreće maven docker kontenjer unutar kojeg se izvrši naredba mvn test koja pokreće kreirane integracijske testove.

\item Korak verzioniranja definiran je u umetnutoj skripti. Skripta vodi brigu o verzijama aplikacije koristeći gitlab api kroz korištenje tagova na zahtjevima spajanja koda za određivanje kako uvećati verziju. Prikaz tijeka verzija aplikacije prikazan je na slici \ref{fig:versioning-tree}. Izbornik s konfiguriranim git tagovima korištenim za izmjene verzije koda prikazan je na slici \ref{fig:label selection}, a kod skripte za verzioniranje aplikacije nalazi se u prilogu 5.
\end{itemize}

\begin{figure}
    \centering
    \includegraphics[width=0.4\linewidth]{Slike/label-selection.png}
    \caption{Prikaz izbora tagova korištenih za verzioniranje aplikacije}
    \label{fig:label selection}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Slike/versioning-tree.png}
    \caption{Prikaz dijagrama verzioniranja aplikacije s pripadajućim oznakama \cite{base58}}
    \label{fig:versioning-tree}
\end{figure}

\begin{itemize}

\item{Korak pakiranja aplikacije, korištenjem gitlab varijabli, dohvaća podatke za pristup docker hub repozitoriju. Gitlab nudi i zadani docker repozitorij koji je mogće koristiti. Prilikom izrade docker kontenjera koji sadrži aplikaciju dodaje mu se tag latest i tag verzije. Prikaz docker hub repozitorija na kojem su vidljive verzije koda nalazi se na slici \ref{fig:docker-versions}}. 

\begin{figure}
    \centering
    \includegraphics[width=0.6\linewidth]{Slike/docker-versions.png}
    \caption{Prikaz popisa posljednje verzioniranih docker kontenjera}
    \label{fig:docker-versions}
\end{figure}

\item Korak implementacije aplikacije izvršava se na gitlab-runner docker kontenjeru, unutar virtuale mašne u oblaku. U ovom koraku pokreće se docker compose konfiguracija kreirana u docker-compose.yaml, datoteci prikazanoj u prilogu 4. Docker compose datotekom konfigurira se docker kontenjer baze podataka, kreiranog servisa i ostatka interne mreže docker kontenjera korištenih za rad aplikacije. Docker compose omogućuje pokretanje skupa docker kontenjera, s unaprijed konfiguriranim vanjskim varijablama, jednom naredbom.




\end{itemize}


\subsection{Automatsko pokretanje testova i osiguranje kvalitete koda}

Prilikom razvoja aplikacije, za svaku kontroler klasu kreiran je set integracijskih testova koje je moguće pokrenuti prilikom pokretanja mvn test naredbe unutar cjevovoda. Ukoliko postoje testovi koji nisu prošli validaciju, prekida se cjevodod i novi kod nije moguće spojiti u develop i main grane. Kreirani integracijski testovi prezentacijskog sloja, upravlanja korisničkim podatcima, dani su u prilogu 1. Po završetku izvođenja koraka testiranja, moguće je otići na prikaz izvršenih pipeline poslova gdje su vidljivi logovi aplikacije, kao i informacija o uspješnosti izvođenja testovova. Na slici \ref{fig:test-log} vidljiv je isječak zaslona logiranog uspjega izgradnje aplikacije i uspješnosti pokrenutih testova. Izvršavanje svih koraka cjevovoda na granama novih značajki i development grani u prosjeku traje tri minute, dok izvršavanje svih koraka cjevovoda na main grani traje u prosjeku četiri minute. Vrijeme trajanja izvršavanja svih koraka cjevovoda objektivno djeluje kratko no, uzevši u obzir da stotine ljudi istovremeno može raditi na istom projektu, velik dio vremena proveden je čekajući izvršavanje svih koraka cjevovoda kako bi kod bilo moguće spojiti u drugu granu. Uzimajući u obzir da je implementacijom kontinuirane integracije osigurano da svaka nova verzija koda provjereno radi, da nije potrebno ulagati resurse u ručno testiranje svih mogućnosti aplikacije, vrijeme provedeno čekajući izvršavanje cjevovoda zanemarivo je u odnosu na vrijeme koje bi bilo potrebno za ručno testiranje i implementaciju svake nove verzije aplikacije. 

Uz pokretanje kreiranih automatskih testova, u cjevovod je vrlo lako dodati korak provjere sigurnosnih opasnosti i skeniranja paketa korištenih u aplikaciji. Za kreiranu aplikaciju konfiguriran je snyk. Snyk je sigurnosna platforma za programere koja omogućuje brzo i lako dodavanje provjere kvalitete koda. Nakon registracije na snyk platformu, korisnika se odmah upita na gojem git servisu senalazi aplikacija i upute za postavljanje snyk koraka u cjevovod aplikacije. Na slici \ref{fig:snyk-select-git} prikazana je snimka zaslona za odabir korištenog git servisa. Pritiskom na "View all integrations" u izborniku se prikazuje veći izbornik u kojem se nalazi i gumb za odabir gitlaba. Odabirom konfiguracije gitlaba i klikom na "Next step", otvara se panel za povezivanje snyk servisa i gitlaba. Komunikacija snyk i gitlab servisa omogućena korištenjem gitlab autentifikacijskog tokena, izbornik za dodavanje tokena prikazan je na slici \ref{fig:snyk-gitlab-token}. Nakon povezivanja gitlab repozitorija, snyk omogućuje postavljanje učestalosti pokretanja snyk provjera. Za kreirani projekt postavljen je interval od jednog tjedna, a posljednji rezultat, prikazan je na slici \ref{fig:snyk-issues}. Snyk, uz samo detektiranje propusta u verzijama paketa korištenim u aplikaciji, nudi kratko objašnjenje problema i prijedog rješenja. Za snyk predložena rješenja za propuste omogućeno je kreiranje zahtjeva za spajanje koda u main granu. Preporuka je lokalno provjeriti hoće li nova verzija korištenog paketa potrgati postojeće funkcionalnosti aplikacije.

\begin{figure}
    \centering
    \includegraphics[width=0.6\linewidth]{Slike/snyk-select-git.png}
    \caption{Prikaz izbornika za konfiguraciju snyk servisa s aplikacijom.\cite{snyk}}
    \label{fig:snyk-select-git}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Slike/snyk-gitlab-token.png}
    \caption{Prikaz izbornika za konfiguraciju konekcije snyk servisa s gitlabom.\cite{snyk}}
    \label{fig:snyk-gitlab-token}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=1\linewidth]{Slike/snyk-issues.png}
    \caption{Prikaz panela pronađenih snyk problema sortiranih po prioritetu.\cite{snyk}}
    \label{fig:snyk-issues}
\end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.6\linewidth]{Slike/test-log.png}
    \caption{Informacije o uspješnosti izvedenih testova iz loga kreiranog tijekom izvođenja cjevovoda}
    \label{fig:test-log}
\end{figure}

\newpage
\section*{Zaključak}

U današnjem okruženju brzog razvoja softvera, bitno je usvojiti prakse koje osiguravaju učinkovitost, kvalitetu i pravovremenu isporuku softverskih rješenja. Kontinuirana integracija (CI) pojavila se kao temeljni koncept u ovom kontekstu. Automatizacijom procesa integriranja promjena koda, izvođenja testova i izgradnje artefakata, CI omogućuje razvojnim timovima otkrivanje i rješavanje problema rano u životnom ciklusu razvoja. To pak dovodi do poboljšane suradnje, smanjenih rizika i brže isporuke softvera.

Cilj ovog rada bio je istražiti i opisati koncept kontinuirane integracije korištenjem GitLab cjevovoda, te istražiti alternativne platforme koje se koriste za kontinuiranu integraciju. Ispitujući temeljna načela i najbolje prakse kontinuirane integracije, nastojano je pružiti opće razumijevanje njegovih prednosti i izazova. GitLab CI je popularan CI/CD alat koji se može koristiti za automatizaciju cijelog cjevovoda isporuke softvera, od upravljanja izvornim kodom do implementacije u produkcijsku okolinu.

Rezultati implementacije pokazali su da CI/CD može značajno poboljšati učinkovitost, kvalitetu i pouzdanost životnog ciklusa razvoja softvera. Proces razvoja jedonstavnije je podijeliti na više ljudi jer razvojni programeri mogu istovremeno raditi na različitim dijelovima koda i biti sigurni da njihove promjene neće pokvariti kreirane funkcionalnosti aplikacije. Kvaliteta koda je također poboljšana, budući da su automatizirani testovi pokretani svaki put kada je napravljena promjena. To je pomoglo u otkrivanju grešaka u ranoj fazi razvoja i spriječilo njihovo uvođenje u produkcijsku okolinu. Konačno, aplikacija je implementirana u produkcijsku okolinu brže i pouzdanije, zahvaljujući automatizaciji procesa implementacije.
Rezultati ovog rada pokazuju da je CI/CD vrijedna praksa koja može pomoći u poboljšanju kvalitete, pouzdanosti i učinkovitosti razvoja softvera. GitLab pipelines je moćna CI/CD platforma koja se može koristiti za automatizaciju cijelog cjevovoda isporuke softvera, olakšavajući razvojnim timovima usvajanje CI/CD praksi.

\newpage
\section*{Sa\v{z}etak}
\addcontentsline{toc}{section}{Sa\v{z}etak}

Ovaj rad istražuje koncept kontinuirane integracije (CI) i njegovu implementaciju pomoću GitLab cjevovoda. Pruža pregled CI-a, njegovih prednosti i izazova te njegovih temeljnih načela i najboljih praksi. Također istražuje različite CI/CD platforme, kao što su Jenkins, Travis CI i GitLab CI, te uspoređuje njihove značajke, funkcionalnost i mogućnosti integracije. Rad zatim predstavlja studiju slučaja web aplikacije razvijene u Javi korištenjem Spring Boot okvira. Aplikacija je backend aplikacija za upravljanje tarantulama u hobiju teraristike. Korisnicima omogućuje upravljanje svojim tarantulama kroz mogućnost praćenja životnog ciklusa i vođenje evidencije o hranjenju i ponašanju. Aplikacija je razvijena korištenjem CI/CD praksi, uključujući GitLab cjevovode. To je uključivalo postavljanje GitLab repozitorija za aplikaciju, definiranje CI/CD konfiguracije i postavljanje faza cjevovoda za kontrolu verzija, izgradnju, testiranje i implementaciju aplikacije u proizvodnju. U radu se također raspravlja o rezultatima implementacije, analizirajući učinkovitost CI/CD u poboljšanju procesa razvoja. Performanse i učinkovitost implementiranog sustava su ocijenjene, ispitujući faktore kao što su vrijeme izgradnje, pokrivenost testom i stope uspješnosti implementacije.
U radu se zaključuje da je CI/CD vrijedna praksa koja može pomoći u poboljšanju učinkovitosti, kvalitete i pouzdanosti životnog ciklusa razvoja softvera. GitLab pipelines je moćna CI/CD platforma koja se može koristiti za automatizaciju cjelokupnog procesa isporuke softvera, od upravljanja izvornim kodom do postavljanja do proizvodnje. Studija slučaja predstavljena u ovom radu pokazuje kako se CI/CD može koristiti za uspješan razvoj i implementaciju složene web aplikacije.

\bigskip
\noindent\textbf{Klju\v{c}ne rije\v{c}i:}: Kontinuirana integracija, CI/CD, GitLab cjevovod, razvoj softvera, automatizacija, testiranje, implementacija, Java, Spring Boot, web aplikacija, kontrola verzija, Docker Hub, kvaliteta koda, tijek razvoja softvera, isporuka softvera.


\newpage
\section*{Abstract}
\addcontentsline{toc}{section}{Abstract}

This paper investigates the concept of continuous integration (CI) and its implementation using GitLab pipelines.  It gives a general overview of CI, highlighting its advantages, difficulties, core values, and recommended practices. Additionally, it investigates and contrasts the features, functionality, and integration skills of several CI/CD platforms, including Jenkins, Travis CI, and GitLab CI. The paper then presents a case study of a web application developed in Java using the Spring Boot framework. The application is a backend application for managing tarantulas in the hobby of terrarium keeping.  It enables users to maintain control over their terrariums, monitor the tarantulas' life cycles, and log information on their feeding and activity. GitLab pipelines were used in the application's CI/CD development. In order to do this, a GitLab repository for the application has been set up, along with a CI/CD setup and pipeline steps for version control, building, testing, and deployment to production. The paper also discusses the results of the implementation, analyzing the effectiveness of CI/CD in improving the development process. The paper comes to the conclusion that the software development lifecycle can be made more effective, high-quality, and reliable by implementing CI/CD. The robust CI/CD platform GitLab pipelines may be used to automate every step of the software delivery process, from source code management to deployment to production. 

\bigskip
\noindent\textbf{Keywords:}  Continuous Integration, CI/CD, GitLab pipeline, software development, automation, testing, deployment, Java, Spring Boot, web application, version control, Docker Hub, code quality, development workflow, software delivery.

\newpage

\printbibliography[heading=bibintoc]

\newpage
\section*{Životopis}
\addcontentsline{toc}{section}{\v{Z}ivotopis}

Valentin Loboda Rođen je 31. listopada 1998. godine u Osijeku. Osnovnu školu pohađa u 
Osnovnoj školi Dalj nakon koje upisuje III. Gimnaziju Osijek koju završava 2017. godine. Po 
završetku srednje škole stječe pravo upisa na Fakultet elektrotehnike, računarstva i informacijskih 
tehnologija gdje 2021. godine upisuje diplomski studij, smjer Računarstvo.





\newpage
\section*{Prilog 1- UserController.java}
\label{prilog 1}
\addcontentsline{toc}{section}{Prilog 1}
UserController.java klasa s definicijom RESTfull pristupnih točaka za manipulaciju korisničkim podatcima.

\begin{lstlisting}[language=Java]

@RestController
@RequiredArgsConstructor
@RequestMapping("/api/users")
public class UserController {

    private final UserService userService;


    @Operation(description = "register new user", summary = "Register new user with provided attributes.")
    @PostMapping("/signup")
    public ResponseEntity<?> signUpUser(@RequestBody final CreateUserDto createUserDto) {
        this.userService.signUp(Mapper.CreateUserToEntity(createUserDto));
        return new ResponseEntity<>(HttpStatus.CREATED);
    }

    @Operation(description = "delete user", summary = "Delete user by id.")
    @DeleteMapping("/delete/{id}")
    public ResponseEntity<?> deleteUser(@PathVariable final Long id) {
        this.userService.deleteUser(id);
        return new ResponseEntity<>(HttpStatus.CREATED);
    }

    @Operation(description = "Returns list of all users",
            summary = "Returns list of all registered users. Requires Admin rights")
    @SecurityRequirement(name = "Bearer Authentication")
    @GetMapping
    public ResponseEntity<Collection<UserDto>> getAllUsers() {
        return new ResponseEntity<>(this.userService.getAll(), HttpStatus.OK);
    }

    @Operation(description = "Returns user found by id", summary = "Returns user found by id.")
    @SecurityRequirement(name = "Bearer Authentication")
    @GetMapping("/{id}")
    public ResponseEntity<UserDto> getUserById(@PathVariable final Long id) {
        return new ResponseEntity<>(this.userService.getById(id), HttpStatus.OK);
    }

    @Operation(description = "Edit user profile",
            summary = "Update user attributes.")
    @SecurityRequirement(name = "Bearer Authentication")
    @PutMapping
    public ResponseEntity<UserDto> updateUser(@RequestBody final User user) {
        return new ResponseEntity<>(this.userService.update(user), HttpStatus.OK);
    }

    @Operation(description = "Activate - deactivate user",
            summary = "Activate - deactivate user by id.")
    @SecurityRequirement(name = "Bearer Authentication")
    @PutMapping("/deactivate/{id}")
    public ResponseEntity<UserDto> toggleActivateDeactivateUserById(@PathVariable final Long id) {
        return new ResponseEntity<>(this.userService.toggleActivateDeactivate(id), HttpStatus.OK);
    }


    @Operation(description = "Give admin permissions",
            summary = "Give admin permissions to user with provided id. Requires Admin rights.")
    @SecurityRequirement(name = "Bearer Authentication")
    @PostMapping("/create-admin")
    public ResponseEntity<?> giveAdminRights(@PathVariable final Long id) {
        return new ResponseEntity<>(userService.createAdmin(id), HttpStatus.OK);
    }

    @Operation(description = "Revoke admin permissions",
            summary = "Revoke admin permissions to user with provided id. Requires Admin rights.")
    @SecurityRequirement(name = "Bearer Authentication")
    @PostMapping("/revoke-admin")
    public ResponseEntity<?> revokeAdminRights(@PathVariable final Long id) {
        return new ResponseEntity<>(userService.revokeAdmin(id), HttpStatus.OK);
    }
}

\end{lstlisting}


\newpage
\section*{Prilog 2 - gitlab-ci.yaml}
\label{prilog 2}
\addcontentsline{toc}{section}{Prilog 2}
gitlab-ci.yml datoteka s konfiguracijom koraka kontinuirane integracije.


\begin{lstlisting}

include:
  - local: 'templates/versioning.yml'

image: docker:latest
services:
  - docker:19.03.12-dind

variables:
  MAVEN_IMAGE: maven:3.8.3-openjdk-17

stages:
  - build
  - test
  - version
  - package
  - deploy

cache:
  paths:
    - .m2/repository
    - target

test:
  stage: test
  tags:
    - docker
  image: $MAVEN_IMAGE
  script:
    - echo "Maven test started"
    - "mvn test"

build-maven:
  image: $MAVEN_IMAGE
  stage: build
  script: "mvn package -B -Dmaven.test.skip=true"
  artifacts:
    paths:
      - target/*.jar

build-and-push-docker:
  stage: package
  before_script:
    - docker login --username $DOCKER_USERNAME --password $DOCKER_ACCESS_TOKEN docker.io
  script:
    - apk add git
    - VERSION=$(git tag --points-at $CI_COMMIT_SHORT_SHA)
    - docker build --pull -t docker.io/vvvaaalll/file-management:$VERSION .
    - docker tag docker.io/vvvaaalll/file-management:$VERSION docker.io/vvvaaalll/file-management:latest
    - docker push --all-tags docker.io/vvvaaalll/file-management
  only:
    - develop
    - main

deploy:
  stage: deploy
  tags:
    - tarantulas
  script:
    - whoami
    - pwd
    - ls -la
    - sudo docker-compose down
    - sudo docker-compose pull
    - sudo docker-compose up -d

  only:
    - main

\end{lstlisting}


\newpage
\section*{Prilog 3 - TarantulaControllerTests.java}
\label{prilog 1}
\addcontentsline{toc}{section}{Prilog 3}
TarantulaControllerTests.java klasa s definicijom integracijskih testova reprezentacijskog sloja

\begin{lstlisting}[language=Java]
package vloboda.tarantulaservice;

import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;

import org.junit.jupiter.api.TestMethodOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import vloboda.filemanagement.dto.CreateTarantulaDto;
import vloboda.filemanagement.dto.TarantulaUpdateDto;
import vloboda.filemanagement.model.Tarantula;
import vloboda.filemanagement.repository.TarantulaRepository;
import vloboda.filemanagement.service.TarantulaService;


import java.util.Optional;

import static org.assertj.core.api.AssertionsForClassTypes.assertThat;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)

public class TarantulaControllerTests extends BaseIT {
    @Autowired
    TarantulaService tarantulaService;
    @Autowired
    TarantulaRepository tarantulaRepository;

    @Test
    @Order(1)
    void shouldReturnEmptyListIfThereAreNoTarantulas() throws Exception {

        mockMvc.perform(get("/tarantulas")
                        .header("Authorization", "Bearer " + getUserAuthToken()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.page.totalElements").value(0));

    }

    @Test
    @Order(2)
    void shouldAddTarantulaSuccessfully() throws Exception {
        CreateTarantulaDto createTarantulaDto = new CreateTarantulaDto();
        createTarantulaDto.setName("Tarantula");
        createTarantulaDto.setHairs(true);
        createTarantulaDto.setOrigin("South America");
        createTarantulaDto.setSpecies("Grammostola pulchripes");
        createTarantulaDto.setVenom("Venomous");
        createTarantulaDto.setTemper("Aggressive");

        String body = objectMapper.writeValueAsString(createTarantulaDto);
        mockMvc.perform(post("/tarantulas")
                        .header("Authorization", "Bearer " + getUserAuthToken())
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(body))
                .andExpect(status().isCreated());
    }

    @Test
    @Order(3)
    void shouldFailToAddTarantulaIfNameIsEmpty() throws Exception {
        CreateTarantulaDto createTarantulaDto = new CreateTarantulaDto();
        createTarantulaDto.setName("");
        createTarantulaDto.setHairs(true);
        createTarantulaDto.setOrigin("South America");
        createTarantulaDto.setSpecies("Grammostola pulchripes");
        createTarantulaDto.setVenom("Venomous");
        createTarantulaDto.setTemper("Aggressive");

        mockMvc.perform(post("/tarantulas")
                        .header("Authorization", "Bearer " + getUserAuthToken())
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(String.valueOf(createTarantulaDto)))
                .andExpect(status().isBadRequest());
    }

    @Test
    @Order(4)
    void shouldFailToAddTarantulaIfUserIsNotAuthenticated() throws Exception {
        CreateTarantulaDto createTarantulaDto = new CreateTarantulaDto();
        createTarantulaDto.setName("Tarantula");
        createTarantulaDto.setHairs(true);
        createTarantulaDto.setOrigin("South America");
        createTarantulaDto.setSpecies("Grammostola pulchripes");
        createTarantulaDto.setVenom("Venomous");
        createTarantulaDto.setTemper("Aggressive");

        mockMvc.perform(post("/tarantulas")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(String.valueOf(createTarantulaDto)))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @Order(5)
    void shouldReturnListOfTarantulas() throws Exception {

        mockMvc.perform(get("/tarantulas")
                        .header("Authorization", "Bearer " + getUserAuthToken()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.page.totalElements").value(1));

    }

    @Test
    @Order(6)
    void shouldFailIfUserIsNotAuthenticated() throws Exception {
        mockMvc.perform(get("/tarantulas"))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @Order(7)
    void shouldReturnNotFoundIfTarantulaNotFound() throws Exception {
        long tarantulaId = 1L;

        mockMvc.perform(get("/tarantulas/{id}", tarantulaId)
                        .header("Authorization", "Bearer " + getUserAuthToken()))
                .andExpect(status().isNotFound());
    }

    @Test
    @Order(8)
    void shouldReturnTarantulaByIdIfFound() throws Exception {
        long tarantulaId = 5L;

        mockMvc.perform(get("/tarantulas/{id}", tarantulaId)
                        .header("Authorization", "Bearer " + getUserAuthToken()))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("Tarantula"));
    }

    @Test
    @Order(9)
    void shouldReturnUnauthorizedIfUserIsNotAuthenticated() throws Exception {
        long tarantulaId = 1L;

        mockMvc.perform(get("/tarantulas/{id}", tarantulaId))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @Order(10)
    void shouldReturnNotFoundIfTarantulaNotFoundForPatchTarantula() throws Exception {
        long tarantulaId = 1L;
        TarantulaUpdateDto tarantulaUpdateDto = new TarantulaUpdateDto();
        tarantulaUpdateDto.setOptionalOfName(Optional.of("New name"));

        mockMvc.perform(patch("/tarantulas/patch/{id}", tarantulaId)
                        .header("Authorization", "Bearer " + getUserAuthToken())
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(tarantulaUpdateDto)))
                .andExpect(status().isNotFound());
    }

    @Test
    @Order(11)
    void shouldUpdateTarantulaIfFound() throws Exception {
        long tarantulaId = 5L;

        TarantulaUpdateDto tarantulaUpdateDto = new TarantulaUpdateDto();
        tarantulaUpdateDto.setOptionalOfName(Optional.of("New name"));

        String body = objectMapper.writeValueAsString(tarantulaUpdateDto);
        mockMvc.perform(patch("/api/tarantula/patch/{id}", tarantulaId)
                        .header("Authorization", "Bearer " + getUserAuthToken())
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(body))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.name").value("New name"));

    }

    @Test
    @Order(12)
    void shouldReturnUnauthorizedIfUserIsNotAuthenticatedForPatchTarantula() throws Exception {
        long tarantulaId = 5L;
        TarantulaUpdateDto tarantulaUpdateDto = new TarantulaUpdateDto();
        tarantulaUpdateDto.setOptionalOfName(Optional.of("New name"));

        mockMvc.perform(patch("/tarantulas/patch/{id}", tarantulaId)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(tarantulaUpdateDto)))
                .andExpect(status().isUnauthorized());
    }

    @Test
    @Order(13)
    void shouldThrowExceptionIfUserNotAuthorized() throws Exception {
        long tarantulaId = 5L;

        mockMvc.perform(delete("/api/tarantula/{id}", tarantulaId))
                .andExpect(status().isUnauthorized());

    }

    @Test
    @Order(14)
    void shouldDeleteTarantulaById() throws Exception {
        long tarantulaId = 5L;

        mockMvc.perform(delete("/api/tarantula/{id}", tarantulaId)
                        .header("Authorization", "Bearer " + getUserAuthToken()))
                .andExpect(status().isNoContent())
                .andExpect(jsonPath("$.message").value("Tarantula deleted successfully."));


        // Verify that the tarantula is no longer in the database
        Optional<Tarantula> tarantulaOptional = tarantulaRepository.findById(tarantulaId);
        assertThat(tarantulaOptional).isEmpty();
    }

    @Test
    @Order(15)
    void shouldThrowExceptionIfIdIsInvalidForDeleteEndpoint() throws Exception {
        long tarantulaId = 28L;

        mockMvc.perform(delete("/api/tarantula/{id}", tarantulaId)
                        .header("Authorization", "Bearer " + getUserAuthToken()))
                .andExpect(jsonPath("$.message").value("Failed to delete tarantula."));


    }
}
\end{lstlisting}

\newpage
\section*{Prilog 4 - docker-compose.yaml}
\label{prilog 4}
\addcontentsline{toc}{section}{Prilog 4}
docker-compose.yaml konfiguracija s definicijom mreže docker kontenjera potrebnih za izvođenje aplikacije i definicija kojom se pokreće docker kontenjer kreirane aplikacije.
\begin{lstlisting}
version: '3.7'

volumes:
  postgres-data:

networks:
  file-management:
    name: file-management
    driver: bridge
    driver_opts:
      com.docker.network.bridge.name: file-management

services:
  file-management:
    image: vvvaaalll/file-management:latest
    environment:
      - SPRING_DATASOURCE_URL=jdbc:postgresql://postgres:5432/postgres
    networks:
      - file-management
    ports:
      - "80:8080"
    depends_on:
      - postgres

  postgres:
    image: postgres:14.1-alpine
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./docker/postgres:/docker-entrypoint-initdb.d
    user: postgres
    environment:
      - POSTGRES_DB=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
    ports:
      - "5432:5432"
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready" ]
      interval: 30s
      timeout: 5s
    networks:
      - file-management
    hostname: postgres

  pgadmin:
    image: dpage/pgadmin4
    restart: always
    ports:
      - "15432:80"
    environment:
      - PGADMIN_DEFAULT_EMAIL=admin@tarantulas.hr
      - PGADMIN_DEFAULT_PASSWORD=admin
      - PGADMIN_LISTEN_ADDRESS=0.0.0.0
    networks:
      - file-management
    depends_on:
      - postgres

\end{lstlisting}

\newpage
\section*{Prilog 5 - versioning.yaml}
\label{prilog 5}
\addcontentsline{toc}{section}{Prilog 5}
versioning.yaml skripta je otvorenog koda, koristi se za verzioniranje maven aplikacije koristeći tagove dodijeljene na zahtjevima spajanja koda.

\begin{lstlisting}

#    MIT License

#    Copyright (c) 2023 Base58 Ltd

#    Permission is hereby granted, free of charge, to any person obtaining a copy
#    of this software and associated documentation files (the "Software"), to deal
#    in the Software without restriction, including without limitation the rights
#    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#    copies of the Software, and to permit persons to whom the Software is
#    furnished to do so, subject to the following conditions:

#    The above copyright notice and this permission notice shall be included in all
#    copies or substantial portions of the Software.

#    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
#    SOFTWARE.

.script-1: &increment_version |
  # ACCESS_TOKEN needs to be configured and defined in secrets
  # Label needs to be added to MR: increment::major. increment::minor or increment::hotfix
  # jq .iid error occurs if a) there is no merge request for the commit, b) curl is melformed, i.e. branch is not protected - has no access to variables
  echo "PRIVATE-TOKEN: glpat-7uryqS1dBhBKmGMcBRyX $CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=merged"
  MR_ID=$(curl $CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=merged|jq '.[] |.iid'|head -n 1)
  #MR_ID=$(curl -s --header "PRIVATE-TOKEN: glpat-7uryqS1dBhBKmGMcBRyX" $CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests?state=merged|jq '.[] |.iid'|head -n 1)
  echo "$MR_ID"
  LABEL=$(curl -s --header "PRIVATE-TOKEN: glpat-7uryqS1dBhBKmGMcBRyX" "$CI_API_V4_URL/projects/$CI_PROJECT_ID/merge_requests/$MR_ID"|jq '.labels | to_entries[]|.value'|grep increment|cut -d '"' -f 2|cut -d ":" -f 3)||LABEL=""
  echo "Merge id is set to \"$MR_ID\", label is set to \"$LABEL\" and branch is set to \"$CI_COMMIT_BRANCH\"."
  if [[ "$LABEL" == "none" ]]; then
    exit 3
  fi
  echo "CI_PROJECT_PATH_SLUG $CI_PROJECT_PATH_SLUG, CI_PROJECT_PATH $CI_PROJECT_PATH"
  git clone https://oauth2:glpat-7uryqS1dBhBKmGMcBRyX@$(echo $CI_PROJECT_URL | grep -oP "^https://\K.*").git
  cd $(echo $CI_PROJECT_PATH|awk -F/ '{print $NF}')
  git config user.email ci@ci.com
  git config user.name ci-user
  git checkout $CI_COMMIT_BRANCH
  START_VERSION=$(git describe 2>&1) || :
  SED_VERSION_REGEX='([0-9]+).([0-9]+).([0-9]+)(.*)'
  HOTFIX_INCREMENT='\1.\2.$((\3+1))-'
  MINOR_INCREMENT='\1.$((\2+1)).0-'
  MAJOR_INCREMENT='$((\1+1)).0.0-'
  SNAPSHOT_INCREMENT='\1.\2.\$((\3+1))-'
  PREVIOUS_TAG_ALL=$(git tag | { grep -e SNAPSHOT -e RELEASE || :; } | sort -V | tail -n1)
  if [[ "$PREVIOUS_TAG_ALL" == "" ]]; then PREVIOUS_TAG_ALL=0.0.0-RELEASE; fi
  PREVIOUS_TAG_RELEASE=$(git tag | { grep -e RELEASE || :; } | sort -V | tail -n1)
  if [[ "$PREVIOUS_TAG_RELEASE" == "" ]]; then PREVIOUS_TAG_RELEASE=0.0.0-RELEASE; fi
  case $CI_COMMIT_BRANCH in
    develop)
      PREVIOUS_TAG=$PREVIOUS_TAG_ALL
      VERSION_TYPE=SNAPSHOT
      if [[ "$PREVIOUS_TAG" =~ .*-RELEASE ]]; then
        INCREMENT_RECIPE=$SNAPSHOT_INCREMENT
        echo "RELEASE detected in version string: \"$PREVIOUS_TAG\"."
      elif [[ "$PREVIOUS_TAG" =~ .*-SNAPSHOT ]]; then
        INCREMENT_RECIPE=$SNAPSHOT_INCREMENT
        echo "SNAPSHOT detected in version string: \"$PREVIOUS_TAG\"."
      else
        echo "RELEASE nor SNAPSHOT detected in version string: \"$PREVIOUS_TAG\"."
      fi;;
    master|main)
      VERSION_TYPE=RELEASE
      PREVIOUS_TAG=$PREVIOUS_TAG_RELEASE
      if [[ "$LABEL" == "major" ]]; then
        INCREMENT_RECIPE=$MAJOR_INCREMENT
      elif [[ "$LABEL" == "hotfix" ]]; then
        INCREMENT_RECIPE=$HOTFIX_INCREMENT
      else
        INCREMENT_RECIPE=$MINOR_INCREMENT
      fi;;
    *)
      echo "No case selected"
      exit 1;;
  esac
  echo  "This job runs for branch \"$CI_COMMIT_BRANCH\", SED_VERSION_REGEX is \"$SED_VERSION_REGEX\"INCREMENT_RECIPE is \"$INCREMENT_RECIPE\"."
  if [[ "$START_VERSION" =~ ^[0-9]+.[0-9]+.[0-9]+-[A-Z]+-.*-.* || "$START_VERSION" =~ ^[0-9]+.[0-9]+.[0-9]+.[0-9]+-[A-Z]+-.*-.* || "$START_VERSION" == "fatal: No names found, cannot describe anything." || "$START_VERSION" == "" ]]; then
    echo "This commit was not previously tagged, continuing tag procedure"
  else
    echo "Skiping tag, this commit is already tagged with $START_VERSION!"
    exit 2
  fi
  echo "Last version, tagged on an previous commit, was $PREVIOUS_TAG"
  git tag -a\
    $(echo $PREVIOUS_TAG |\
    sed -r 's/'"$SED_VERSION_REGEX"'/echo '"$INCREMENT_RECIPE$VERSION_TYPE"'/ge')\
    -m "update version - increment \"$VERSION_TYPE\" position for \"$CI_COMMIT_BRANCH branch\"" $CI_COMMIT_SHA
  git push -o ci.skip --follow-tag

version_bump:
  image: vvvaaalll/git
  stage: version
  variables:
    GIT_STRATEGY: none
  script:
    - rm -rf ./*
    - *increment_version
  allow_failure:
    exit_codes:
      - 2
      - 3
  only:
    - main
    - develop

\end{lstlisting}

\newpage
\section*{Prilog 6 - OpenApiConfiguration.java}
\label{prilog 6}
\addcontentsline{toc}{section}{Prilog 6}
OpenApiConfiguration klasa s definicijom swagger dokumentacije.

\begin{lstlisting}[language=Java]

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import org.springdoc.core.GroupedOpenApi;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecurityScheme(
        name = "Bearer Authentication",
        type = SecuritySchemeType.HTTP,
        bearerFormat = "JWT",
        scheme = "bearer"
)
public class OpenApiConfiguration {

    @Bean
    public OpenAPI springOpenAPI() {
        return new OpenAPI()
                .info(
                        new Info()
                                .title("Tarantulas backend service")
                                .description("Manage user access and data, add and manage tarantulas and image files")
                                .license(
                                        new License()
                                                .name("Apache 2.0")
                                                .url("http://www.apache.org/licenses/LICENSE-2.0")));
    }


    @Bean
    public GroupedOpenApi publicApiImageFiles() {
        return GroupedOpenApi.builder()
                .group("Image files management")
                .pathsToMatch("/api/image-file/**")
                .build();
    }

    @Bean
    public GroupedOpenApi publicApiTarantula() {
        return GroupedOpenApi.builder()
                .group("Tarantulas management")
                .pathsToMatch("/api/tarantula/**")
                .build();
    }

    @Bean
    public GroupedOpenApi UsersApi() {
        return GroupedOpenApi.builder()
                .group("Users")
                .pathsToMatch("/api/users/**")

                .build();
    }

    @Bean
    public GroupedOpenApi AuthApi() {
        return GroupedOpenApi.builder()
                .group("Authentication")
                .pathsToMatch("/api/token/**")

                .build();
    }

}


\end{lstlisting}



\end{document}